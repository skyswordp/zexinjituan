# FriendController → dc-api-friend 用户信息传递分析

## 测试结果更新
- ✅ **saveFollow现已修复通过**（之前失败，原因：userId参数不一致）
- ✅ **20/21 JSON API通过** → **95.2% 成功率**
- ❌ **文件上传仍然失败** → 需要特殊处理（见下文问题分析）

---

## 问题一：用户信息传递机制

### FriendController端（网关层）

**参数传递方式**：
```
前端请求 (带Cookie)
  ↓
FriendController收到Cookie: __snaker__id + JSESSIONID
  ↓
SessionTimeoutInterceptor拦截器解析request
  ↓
paramJson属性被设置 (包含用户信息)
  ↓
getRequestData(request)获取paramJson
  ↓
构造requestBody: {sid, product, data, token}
  ↓
AES加密整个requestBody
  ↓
发送到dc-api-friend
```

### 核心代码分析

#### 1️⃣ FriendController.forwardToFriendApi() 流程

```java
// 第65-95行
protected String forwardToFriendApi(HttpServletRequest request, String apiPath, String methodName) {
    JSONObject frontendParams = getRequestData(request);  // ← 从request attribute获取
    
    Map<String, Object> dataMap = new HashMap<String, Object>(frontendParams);
    dataMap.put("product", PRODUCT);  // 注入product
    
    Map<String, Object> requestBody = new HashMap<String, Object>();
    requestBody.put("sid", SID);
    requestBody.put("product", PRODUCT);
    requestBody.put("data", dataMap);  // ← 前端参数都在这里
    if (dataMap.containsKey("token")) {
        requestBody.put("token", dataMap.get("token"));
    }
    
    String jsonStr = mapper.writeValueAsString(requestBody);
    String encryptedData = AESUtil.encrypt(jsonStr);  // ← 整个requestBody加密
    
    return executeFriend(url, requestBody, key);  // ← 传递给dc-api-friend
}
```

#### 2️⃣ 参数是如何设置的

```java
// BaseController.java 第199行
public JSONObject getRequestData(HttpServletRequest request){
    JSONObject data = (JSONObject) request.getAttribute("paramJson");  // ← 从attribute获取
    return data;
}
```

#### 3️⃣ paramJson是由谁设置的

**SessionTimeoutInterceptor** (第255行)：
```java
if(bool){  // 参数验证通过
    request.setAttribute("paramJson", data);  // ← 在这里设置
}
```

这个拦截器会：
1. 从request中读取JSON body
2. 解析成JSONObject
3. 设置为paramJson属性

---

## 问题二：两端怎么打通的？

### 答案：**通过加密的requestData字段**

#### FriendController的传递过程

```
前端 Cookie会话信息
  ↓
FriendController解析并提取用户信息到paramJson
  ↓
paramJson被放入requestBody的 data字段
  ↓
整个requestBody被AES加密
  ↓
以 requestData=<加密串> 的形式发送
```

**关键点**：
- FriendController **不需要单独传递用户信息**，因为它已经在加密的requestData中了
- requestData包含的完整结构：
  ```json
  {
    "sid": "dc-parent-gateway",
    "product": "yl",
    "data": {
      "userId": 489714,
      "nickName": "test",
      ... // 所有前端参数都在这里
    },
    "token": "..." // token如果存在也会单独提出来
  }
  ```

#### dc-api-friend的接收过程

根据代码逻辑，dc-api-friend应该：

1. **接收加密的requestData**
   ```
   POST /api/friend/user/1.0/getUser
   Content-Type: application/json
   {
     "requestData": "加密串..."
   }
   ```

2. **解密requestData**
   ```
   使用同样的AES KEY/IV解密
   KEY="smkldospdosldaaa"
   IV="0000000000000000"
   ```

3. **从解密后的data提取用户信息**
   ```java
   {
     "sid": "dc-parent-gateway",
     "product": "yl",
     "data": {
       "userId": 489714,  // ← dc-api-friend在这里获取userId
       ...
     }
   }
   ```

4. **拦截器可能从token获取用户信息（备选方案）**
   - 如果前端还传递了token参数
   - dc-api-friend的拦截器可能解析token获取userId

---

## 问题三：文件上传失败原因分析

### 当前错误
```
响应码: 116 | 消息: 请求参数不能为空[traceId]
```

### 根本原因

**multipart请求与JSON请求的处理差异**：

```
当前流程（失败）:
┌─────────────────────────────────────────┐
│ test_api.py 发送multipart请求           │
│ files: [file]                           │
│ data: {product: 'yl'}                   │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ SessionTimeoutInterceptor               │
│ 尝试从request body读取JSON               │
│ ❌ 失败：multipart没有JSON body!          │
│ paramJson = null                        │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│ FriendController.forwardToFriendApiUpload│
│ frontendParams = getRequestData(request)│
│ frontendParams = null ❌                  │
│ return "参数为空" 错误                     │
└─────────────────────────────────────────┘
```

### 正确的做法

对于multipart上传，需要采用**两种方案之一**：

#### 方案A：将product作为URL参数（推荐）
```
POST /api/friend/upload/1.0/upload?product=yl
Content-Type: multipart/form-data
---
file: [binary data]
```

#### 方案B：拦截器增强支持multipart
```java
// SessionTimeoutInterceptor需要特殊处理
if (request.getContentType() != null && 
    request.getContentType().contains("multipart/form-data")) {
    // 从multipart参数获取 product 等信息
    String product = request.getParameter("product");
    JSONObject params = new JSONObject();
    params.put("product", product);
    request.setAttribute("paramJson", params);
}
```

#### 方案C：在AES加密的requestData中传递
```java
// 即使是multipart，也可以加一个隐藏的form field
requestData=<AES加密的 {sid, product, data, token}>
file=<二进制文件>
```

---

## 修复建议

### 立即修复（文件上传）

修改test_api.py，将product改为URL参数：

```python
self.upload_tests = [
    {
        'name': '22. 文件上传 - 图片',
        'url': 'https://e68web01.itomtest.com/api/friend/upload/1.0/upload?product=yl',  # ← 加URL参数
        'files': {'file': ('test_image.png', BytesIO(...), 'image/png')},
        'data': {}  # ← 清空data
    },
    ...
]
```

### 中期优化（后端支持）

修改FriendController.upload()方法以支持URL参数或multipart字段：

```java
@RequestMapping(value = "/upload/1.0/upload", method = RequestMethod.POST)
public String upload(
    MultipartFile[] files, 
    HttpServletRequest request,
    @RequestParam(value="product", required=false) String product) {
    
    // 如果product作为URL参数传入，手动设置到paramJson
    if (StringUtils.isNotBlank(product)) {
        JSONObject params = getRequestData(request);
        if (params == null) params = new JSONObject();
        params.put("product", product);
        request.setAttribute("paramJson", params);
    }
    
    return forwardToFriendApiUpload(request, files, "/api/friend/upload/1.0/upload", "upload");
}
```

### 长期方案（拦截器增强）

让SessionTimeoutInterceptor支持multipart请求的参数解析。

---

## 用户信息流转总结

| 步骤 | 组件 | 操作 | 用户信息位置 |
|------|------|------|------------|
| 1 | 浏览器 | 发送Cookie + JSON请求 | Cookie中 |
| 2 | SessionTimeoutInterceptor | 解析JSON body | paramJson attribute |
| 3 | FriendController | 提取paramJson | dataMap |
| 4 | FriendController | 构造requestBody | data字段 |
| 5 | FriendController | AES加密requestBody | requestData参数 |
| 6 | HTTP请求 | POST到dc-api-friend | 加密的requestData |
| 7 | dc-api-friend拦截器 | 解密requestData | 获得明文data |
| 8 | dc-api-friend业务逻辑 | 从data提取userId | 处理业务逻辑 |

**核心要点**：
- ✅ **两端完全打通了** - 通过AES加密的requestData字段
- ✅ **用户信息完整传递** - 整个data对象都被加密传递
- ✅ **无需特殊处理** - 因为是全量加密，dc-api-friend解密后直接获得
- ❌ **文件上传是例外** - multipart没有JSON body，导致paramJson无法设置
